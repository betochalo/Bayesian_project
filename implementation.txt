import numpy as np

def ode45(f, tspan, y0, h0=0.1, rtol=1e-3, atol=1e-6):
    t0, tf = tspan
    t = t0
    y = y0
    h = h0
    t_out = [t]
    y_out = [y]
    while t < tf:
        # Step 1
        k1 = h * f(t, y)
        # Step 2
        k2 = h * f(t + h/2, y + k1/2)
        # Step 3
        k3 = h * f(t + h/2, y + k2/2)
        # Step 4
        k4 = h * f(t + h, y + k3)
        # Compute the new value of y
        y_new = y + (k1 + 2*k2 + 2*k3 + k4)/6
        # Compute the error estimate
        delta = np.abs(y_new - y)
        error_norm = np.sqrt(np.mean((delta / (atol + rtol*np.abs(y_new)))**2))
        # Compute the new step size
        h_new = h * 0.8 * error_norm**(-1/5)
        if error_norm < 1:
            t = t + h
            y = y_new
            t_out.append(t)
            y_out.append(y)
        # Ensure that the next step does not go beyond tf
        h = min(h_new, tf - t)
    return np.array(t_out), np.array(y_out)


# Define the ODE system
def f(t, y):
    return np.array([-y[1], y[0]])

# Set the initial conditions and time points
y0 = np.array([0, 1])
tspan = (0, 10)

# Solve the ODE using ode45-like solver
t, y = ode45(f, tspan, y0)

# Plot the solution
import matplotlib.pyplot as plt
plt.plot(t, y[:,0], label='y1')
plt.plot(t, y[:,1], label='y2')
plt.legend()
plt.show()
